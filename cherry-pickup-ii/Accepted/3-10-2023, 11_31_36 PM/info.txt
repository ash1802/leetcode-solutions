{"id":912823205,"lang":"cpp","lang_name":"C++","time":"2 months, 3 weeks","timestamp":1678471296,"status":10,"status_display":"Accepted","runtime":"183 ms","url":"/submissions/detail/912823205/","is_pending":"Not Pending","title":"Cherry Pickup II","memory":"9.2 MB","code":"class Solution {\npublic:\n    // memoization solution here\n    int solve(int i, int j1, int j2, int n, int m, vector<vector<int>> &grid, vector<vector<vector<int>>> &dp)\n    {\n        // base cases here: overflow and destination reached\n        if (j1 < 0 || j1 >= m || j2 < 0 || j2 >= m) return -1e9;\n        if (i == n - 1)\n        {\n            if (j1 == j2) return grid[i][j1];\n            else return grid[i][j1] + grid[i][j2];\n        }\n\n\n        if (dp[i][j1][j2] != -1) return dp[i][j1][j2];\n\n        int maxi = INT_MIN;\n        for (int di = -1; di <= 1; di++)\n        {\n            for (int dj = -1; dj <= 1; dj++)\n            {\n                int ans = 0;\n                if (j1 == j2) ans = grid[i][j1] + solve(i + 1, j1 + di, j2 + dj, n, m, grid, dp);\n                else ans = grid[i][j1] + grid[i][j2] + solve(i + 1, j1 + di, j2 + dj, n, m, grid, dp);\n                maxi = max(maxi, ans);\n            }\n        }\n\n        return dp[i][j1][j2] = maxi;\n    }\n\n    int cherryPickup(vector<vector<int>>& grid) {\n        int n = grid.size();\n        int m = grid[0].size();\n        // vector<vector<vector<int>>> dp(n, vector<vector<int>>(m, vector<int>(m, -1)));\n        // return solve(0, 0, m - 1, n, m, grid, dp);\n\n        // tabulation solution here\n        // vector<vector<vector<int>>> dp(n, vector<vector<int>>(m, vector<int>(m, 0)));\n        // for(int j1 = 0; j1 < m; j1++) {\n        //     for(int j2 = 0; j2 < m; j2++) {\n        //         if(j1 == j2) dp[n-1][j1][j2] = grid[n-1][j1];\n        //         else dp[n-1][j1][j2] = grid[n-1][j1] + grid[n-1][j2];\n        //     }\n        // }\n\n        // for(int i = n-2; i>=0; i--) {\n        //     for(int j1 = 0; j1 < m; j1++) {\n        //         for(int j2 = 0; j2 < m; j2++) {\n        //             int maxi = INT_MIN;\n        //             for (int di = -1; di <= 1; di++)\n        //             {\n        //                 for (int dj = -1; dj <= 1; dj++)\n        //                 {\n        //                     int ans = 0;\n        //                     if (j1 + di < 0 || j1 + di >= m || j2 + dj < 0 || j2 + dj >= m) ans += -1e9;\n        //                     else {\n        //                         if (j1 == j2) ans = grid[i][j1] + dp[i + 1][j1 + di][j2 + dj];\n        //                         else ans = grid[i][j1] + grid[i][j2] + dp[i + 1][j1 + di][j2 + dj];\n        //                     }\n        //                     maxi = max(maxi, ans);\n        //                 }\n        //             }\n\n        //             dp[i][j1][j2] = maxi;\n        //         }\n        //     }   \n        // }\n        \n        // return dp[0][0][m-1];\n\n        // space optimisation solution here\n        vector<vector<int>> front(m, vector<int>(m, 0)), cur(m, vector<int>(m, 0));\n\n        for (int j1 = 0; j1 < m; j1++) {\n            for (int j2 = 0; j2 < m; j2++) {\n                if (j1 == j2) front[j1][j2] = grid[n - 1][j1];\n                else front[j1][j2] = grid[n - 1][j1] + grid[n - 1][j2];\n            }\n        }\n\n        //Outer Nested Loops for traversing DP Array\n        for (int i = n - 2; i >= 0; i--) {\n            for (int j1 = 0; j1 < m; j1++) {\n                for (int j2 = 0; j2 < m; j2++) {\n                    int maxi = INT_MIN;\n                    //Inner nested loops to try out 9 options\n                    for (int di = -1; di <= 1; di++) {\n                        for (int dj = -1; dj <= 1; dj++) {\n                            int ans;\n                            if (j1 == j2) ans = grid[i][j1];\n                            else ans = grid[i][j1] + grid[i][j2];\n                            if ((j1 + di < 0 || j1 + di >= m) || (j2 + dj < 0 || j2 + dj >= m)) ans += -1e9;\n                            else ans += front[j1 + di][j2 + dj];\n                            maxi = max(ans, maxi);\n                        }\n                    }\n                    cur[j1][j2] = maxi;\n                }\n            }\n            \n            front = cur;\n        }\n\n        return front[0][m - 1];\n    }\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111","title_slug":"cherry-pickup-ii","has_notes":false}