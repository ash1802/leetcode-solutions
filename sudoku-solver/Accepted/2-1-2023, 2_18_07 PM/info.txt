{"id":889294927,"lang":"cpp","lang_name":"C++","time":"4Â months","timestamp":1675241287,"status":10,"status_display":"Accepted","runtime":"40 ms","url":"/submissions/detail/889294927/","is_pending":"Not Pending","title":"Sudoku Solver","memory":"6.5 MB","code":"class Solution {\npublic:\nbool isSafe(vector<vector<char>> &board, int r, int c, char ch)\n{\n    for (int i = 0; i < 9; i++)\n    {\n        // check for same column\n        if (board[i][c] == ch)\n            return false;\n        // check for same row\n        if (board[r][i] == ch)\n            return false;\n        // check if in the current element's 3x3 grid for same number\n        // logic is : row or col / 3 = {0,1,2}\n        // {0,1,2} * 3 = {0,3,6} - takes to the starting rows for grids\n        // now we add i/3 to row and i%3 to column, since i/3 changes slower and i%3 fluctuates like column value\n        if (board[3 * (r / 3) + i / 3][3 * (c / 3) + i % 3] == ch)\n            return false;\n    }\n    return true;\n}\n\n// function that will check for each empty space whether a particular number can be filled or not\nbool solve(vector<vector<char>> &board)\n{\n    for (int i = 0; i < board.size(); i++)\n    {\n        for (int j = 0; j < board[0].size(); j++)\n        {\n            if (board[i][j] == '.')\n            {\n                for (char c = '1'; c <= '9'; c++)\n                {\n                    // if it is a safe square for that particular character\n                    if (isSafe(board, i, j, c))\n                    {\n                        // place it onto the board\n                        board[i][j] = c;\n                        // if placing that character leads to a solution, then return true\n                        if (solve(board) == true)\n                            return true;\n                        // otherwise backtrack to find another solution\n                        else\n                            board[i][j] = '.';\n                    }\n                }\n\n                // if a particular cell cannot be filled with any element, that means we need to backtrack\n                return false;\n            }\n        }\n    }\n\n    // control reaches here if the loop is completed successfully\n    return true;\n}\n\nvoid solveSudoku(vector<vector<char>> &board)\n{\n    solve(board);\n}\n\n};","compare_result":"111111","title_slug":"sudoku-solver","has_notes":false}