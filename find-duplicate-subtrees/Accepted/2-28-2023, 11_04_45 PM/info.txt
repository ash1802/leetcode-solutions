{"id":906630895,"lang":"cpp","lang_name":"C++","time":"3Â months","timestamp":1677605685,"status":10,"status_display":"Accepted","runtime":"56 ms","url":"/submissions/detail/906630895/","is_pending":"Not Pending","title":"Find Duplicate Subtrees","memory":"64.8 MB","code":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    unordered_map<string, int> map;\n    vector<TreeNode*> nodelist;\n    \n    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\n        recc(root);\n        return nodelist;\n    }\n    \n    string recc(TreeNode* root) {\n        if (!root) {\n            return \"null\";\n        }\n        \n        string leftNodepath = recc(root->left);\n        string rightNodepath = recc(root->right);\n        \n        // Hashmap will store the path of node as key and its freq is checked\n        // that the same path string matches mimicking the same subtree\n        string path = to_string(root->val) + \", \" + leftNodepath + \", \" + rightNodepath;\n        \n        map[path]++;\n        \n        if (map[path] == 2) {\n            nodelist.push_back(root);\n        }\n        \n        return path;\n    }\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"find-duplicate-subtrees","has_notes":false}