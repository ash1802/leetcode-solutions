{"id":887337158,"lang":"cpp","lang_name":"C++","time":"4Â months","timestamp":1674978349,"status":10,"status_display":"Accepted","runtime":"628 ms","url":"/submissions/detail/887337158/","is_pending":"Not Pending","title":"LFU Cache","memory":"205.8 MB","code":"// a node class for storing (key,value,count) in list\nstruct Node {\n    int key, value, cnt;\n    Node *next; \n    Node *prev;\n    Node(int _key, int _value) {\n        key = _key;\n        value = _value; \n        cnt = 1; \n    }\n}; \n\n// a list class that has functionalities for adding and removing (doubly linked list)\nstruct List {\n    int size; \n    Node *head; \n    Node *tail; \n    List() {\n        head = new Node(0, 0); \n        tail = new Node(0,0); \n        head->next = tail;\n        tail->prev = head; \n        size = 0;\n    }\n    \n    void addFront(Node *node) {\n        Node* temp = head->next;\n        node->next = temp;\n        node->prev = head;\n        head->next = node;\n        temp->prev = node;\n        size++; \n    }\n    \n    void removeNode(Node* delnode) {\n        Node* delprev = delnode->prev;\n        Node* delnext = delnode->next;\n        delprev->next = delnext;\n        delnext->prev = delprev;\n        size--; \n    }\n};\n\nclass LFUCache {\n    // one map to store the occurence of nodes\n    map<int, Node*> keyNode; \n    // another map that has frequency values mapped to list containing nodes that have occured \n    // that many times\n    map<int, List*> freqListMap; \n    int maxSizeCache;\n    // maintain the current minimum frequency for deletion purposes\n    int minFreq; \n    int curSize; \npublic:\n    LFUCache(int capacity) {\n        maxSizeCache = capacity; \n        minFreq = 0;\n        curSize = 0; \n    }\n\n    // a function to delete a node from one freq. list and insert into another freq. list\n    void updateFreqListMap(Node *node) {\n        // remove old address from map \n        keyNode.erase(node->key); \n        // remove from old frequency list\n        freqListMap[node->cnt]->removeNode(node); \n\n        if(node->cnt == minFreq && freqListMap[node->cnt]->size == 0) {\n            minFreq++; \n        }\n\n        // create a new list to store in a new frequency         \n        List* nextHigherFreqList = new List();\n        // if the next frequency list exists, get it\n        if(freqListMap.find(node->cnt + 1) != freqListMap.end()) {\n            nextHigherFreqList = freqListMap[node->cnt + 1];\n        } \n\n        // increase the count of the node\n        node->cnt += 1; \n        // add this node to the front of the list (most recently used)\n        nextHigherFreqList->addFront(node); \n        // add the list to the current node count map\n        freqListMap[node->cnt] = nextHigherFreqList; \n        // add the current node to the keynode map\n        keyNode[node->key] = node;\n    }\n    \n    // function to get an element from the LFU\n    int get(int key) {\n        if(keyNode.find(key) != keyNode.end()) {\n            Node* node = keyNode[key]; \n            int val = node->value; \n            // update the frequency of the node once accessed\n            updateFreqListMap(node); \n            return val; \n        }\n        // key not found case\n        return -1; \n    }\n    \n    void put(int key, int value) {\n        // cannot put if capacity itself is zero\n        if (maxSizeCache == 0) {\n            return;\n        }\n        // if node already exists\n        if(keyNode.find(key) != keyNode.end()) {\n            Node* node = keyNode[key]; \n            // update the value\n            node->value = value; \n            // update both the maps with the new values\n            updateFreqListMap(node); \n        }\n\n        // otherwise perform new insertion\n        else {\n            // if cache full\n            if(curSize == maxSizeCache) {\n                // get the minimum frequency list\n                List* list = freqListMap[minFreq]; \n                // remove the LRU node from the map\n                keyNode.erase(list->tail->prev->key); \n                // remove this node from the list as well\n                freqListMap[minFreq]->removeNode(list->tail->prev);\n                // reduce the size\n                curSize--; \n            }\n            // increase the size for new element\n            curSize++; \n            // since new element has come, minimum frequency is 1\n            minFreq = 1; \n\n            // create a new list or get the minimum frequency list if it exists\n            List* listFreq = new List(); \n            if(freqListMap.find(minFreq) != freqListMap.end()) {\n                listFreq = freqListMap[minFreq]; \n            }\n\n            // create a new node for the given value and insert it into the list and maps\n            Node* node = new Node(key, value); \n            listFreq->addFront(node);\n            keyNode[key] = node; \n            freqListMap[minFreq] = listFreq; \n        }\n    }\n};","compare_result":"11111111111111111111111111","title_slug":"lfu-cache","has_notes":false}