{"id":889165004,"lang":"cpp","lang_name":"C++","time":"4Â months","timestamp":1675224690,"status":14,"status_display":"Time Limit Exceeded","runtime":"N/A","url":"/submissions/detail/889165004/","is_pending":"Not Pending","title":"Longest Palindromic Substring","memory":"N/A","code":"class Solution {\n    bool isPalindrome(string str) {\n        if(str == \"\") return true;\n        string rev = str;\n        reverse(rev.begin(), rev.end());\n        return rev == str;\n    }\npublic:\n    string longestPalindrome(string s) {\n        string ans = \"\";\n        if(s.length() == 1) return s;\n\n        \n        for(int i=0; i<s.size(); i++) {\n            for(int j=i+1; j<s.size(); j++) {\n                string sub = s.substr(i,j-i+1);\n                if(isPalindrome(sub) && sub.size() > ans.size()) ans = sub;\n            }\n        }\n\n        if(ans == \"\") ans += s[0];\n        return ans;\n    }\n};\n\n/*\nIf we use brute-force and check whether for every start and end position a substring is a palindrome we have O(n^2) start - end pairs and O(n) palindromic checks. Can we reduce the time for palindromic checks to O(1) by reusing some previous computation.\n*/","compare_result":"111111111111111111111111111111111111111111111111111111110000000000000000000000000000000000000000000000000000000000000000000000000000000000000","title_slug":"longest-palindromic-substring","has_notes":false}