{"id":831759013,"lang":"cpp","lang_name":"C++","time":"7 months, 1 week","timestamp":1666921696,"status":14,"status_display":"Time Limit Exceeded","runtime":"N/A","url":"/submissions/detail/831759013/","is_pending":"Not Pending","title":"LRU Cache","memory":"N/A","code":"class LRUCache {\n  public:\n    class node {\n      public:\n        int key;\n      int val;\n      node * next;\n      node * prev;\n      node(int _key, int _val) {\n        key = _key;\n        val = _val;\n      }\n    };\n\n  node * head = new node(-1, -1);\n  node * tail = new node(-1, -1);\n\n  int cap;\n  unordered_map < int, node * > m;\n\n  LRUCache(int capacity) {\n    cap = capacity;\n    head -> next = tail;\n    tail -> prev = head;\n  }\n\n  void addnode(node * newnode) {\n    node * temp = head -> next;\n    newnode -> next = temp;\n    newnode -> prev = head;\n    head -> next = newnode;\n    temp -> prev = newnode;\n  }\n\n  void deletenode(node * delnode) {\n    node * delprev = delnode -> prev;\n    node * delnext = delnode -> next;\n    delprev -> next = delnext;\n    delnext -> prev = delprev;\n  }\n\n  int get(int key_) {\n    if (m.find(key_) != m.end()) {\n      node * resnode = m[key_];\n      int res = resnode -> val;\n      m.erase(key_);\n      deletenode(resnode);\n      addnode(resnode);\n      m[key_] = head -> next;\n      return res;\n    }\n\n    return -1;\n  }\n\n  void put(int key_, int value) {\n    if (m.find(key_) != m.end()) {\n      node * existingnode = m[key_];\n      m.erase(key_);\n      deletenode(existingnode);\n    }\n    if (m.size() == cap) {\n      m.erase(tail -> prev -> key);\n      deletenode(tail -> prev);\n    }\n\n    addnode(new node(key_, value));\n    m[key_] = head -> next;\n  }\n};","compare_result":"1111111111111111111100","title_slug":"lru-cache","has_notes":false}