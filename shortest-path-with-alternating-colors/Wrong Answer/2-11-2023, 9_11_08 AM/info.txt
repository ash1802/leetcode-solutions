{"id":895691581,"lang":"cpp","lang_name":"C++","time":"3 months, 3 weeks","timestamp":1676086868,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/895691581/","is_pending":"Not Pending","title":"Shortest Path with Alternating Colors","memory":"N/A","code":"class Solution {\npublic:\n    vector<int> shortestAlternatingPaths(int n, vector<vector<int>>& redEdges, vector<vector<int>>& blueEdges) {\n        unordered_map<int, list<pair<int,int>>> adj;\n\n        // 0 = red\n        for(int i=0; i<redEdges.size(); i++) {\n            adj[redEdges[i][0]].push_back({redEdges[i][1], 0});\n        }\n        \n        //1 = blue\n        for(int i=0; i<blueEdges.size(); i++) {\n            adj[blueEdges[i][0]].push_back({blueEdges[i][1], 1});\n        }\n\n        queue<int> q;\n        vector<int> ans;\n        q.push(0);\n        bool isRed = true;\n\n        while(!q.empty()) {\n            int src = q.front();\n            q.pop();\n\n            ans.push_back(src);\n\n            for(auto dest : adj[src]) {\n                if((isRed && dest.second == 0) || (!isRed && dest.second == 1)) {\n                    q.push(dest.first);\n                }\n            }\n            isRed = !isRed;\n        }\n\n        int i = ans.size();\n        while(i < n) {\n            ans.push_back(-1);\n            i++;\n        }\n\n        return ans;\n    }\n};","compare_result":"111100110000000000000000000000000000000000000000000000000000000000000000000000000000000000","title_slug":"shortest-path-with-alternating-colors","has_notes":false}