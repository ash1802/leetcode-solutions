{"id":895693795,"lang":"cpp","lang_name":"C++","time":"3 months, 3 weeks","timestamp":1676087313,"status":10,"status_display":"Accepted","runtime":"27 ms","url":"/submissions/detail/895693795/","is_pending":"Not Pending","title":"Shortest Path with Alternating Colors","memory":"16 MB","code":"class Solution {\npublic:\n    vector<int> shortestAlternatingPaths(int n, vector<vector<int>>& redEdges, vector<vector<int>>& blueEdges) {\n        unordered_map<int, list<pair<int,int>>> adj;\n\n        // 0 = red\n        for(int i=0; i<redEdges.size(); i++) {\n            adj[redEdges[i][0]].push_back({redEdges[i][1], 0});\n        }\n        \n        // 1 = blue\n        for(int i=0; i<blueEdges.size(); i++) {\n            adj[blueEdges[i][0]].push_back({blueEdges[i][1], 1});\n        }\n\n        vector<int> ans(n,-1);\n        queue<vector<int>> q;\n        q.push(vector<int>{0,0,-1});\n        \n        while(!q.empty()) {\n            auto front = q.front();\n            q.pop();\n\n            // find the distance of the current node\n            ans[front[0]] = ans[front[0]] != -1 ? ans[front[0]] : front[1];\n            \n            for(auto &dest : adj[front[0]]) {\n\t\t\t\t//Push the node to the queue only if the next edge color is different from the pervious edge color and also if we are visiting the edge\n\t\t\t\t//for the first time.\n                if(front[2] != dest.second && dest.first != -1) {\n                    q.push(vector<int>{dest.first, front[1] + 1, dest.second});\n\t\t\t\t\t//Update the value in the adjacency matrix to -1 to denote that the node has already been visited.\n                    dest.first = -1;\n                }\n            }\n        }\n\n        return ans;\n    }\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"shortest-path-with-alternating-colors","has_notes":false}