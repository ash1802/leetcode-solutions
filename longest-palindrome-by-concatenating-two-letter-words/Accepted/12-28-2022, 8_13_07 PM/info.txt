{"id":866981979,"lang":"cpp","lang_name":"C++","time":"5Â months","timestamp":1672238587,"status":10,"status_display":"Accepted","runtime":"519 ms","url":"/submissions/detail/866981979/","is_pending":"Not Pending","title":"Longest Palindrome by Concatenating Two Letter Words","memory":"200.3 MB","code":"class Solution {\npublic:\n    int longestPalindrome(vector<string>& words) {\n                int len = 0;\n        int count = 0;\n        bool flag = 0;\n        // store all the strings with their number of occurences\n        unordered_map<string,int> mp;\n        for(int i = 0;i<words.size();i++)\n        {\n            mp[words[i]]++;\n        }\n        // now check cases\n        for(int i = 0;i<words.size();i++)\n        {\n            // if s[0] != s[1]\n            if(words[i][0] != words[i][1])\n            {\n              string s = \"\";\n              // store the reverse\n              s += words[i][1];\n              s += words[i][0];\n              // if we find the reverse in the map\n              // we take the minimum count\n              // we do len = count*4 because each string has 2 characters\n              if(mp.find(s) != mp.end())\n              {\n                count = min(mp[words[i]],mp[s]);\n                len += count*4;\n              }\n              // erase the words which are already counted including the reverse one\n              mp.erase(words[i]);\n              mp.erase(s);\n            }\n            // if s[0] == s[1]\n            else if(words[i][0] == words[i][1])\n            {\n                // get number of occurence of such string\n                count = mp[words[i]];\n                // if that string occur even number of times\n                if(mp[words[i]]%2==0)\n                {\n                    // if its even\n                    len += count*2;\n                }\n                else{\n                    // if its odd\n                    // flag = 0 means its the first string that occurs odd number of times\n                    // if its the first one then we can use all its occurences for our result\n                    if(flag==0)\n                    {\n                      // means its the first string which is equal but odd occurence\n                      len += count*2;\n                      // make sure to turn the flag=1 because we already have one string with odd number of occurences in our output now\n                      flag = 1;\n                    }\n                    else{\n                        // if flag = 1 already then we need to count -1 from the all occurence of that string\n                        len += (count-1)*2;\n                    }\n                }\n                // erase that word from the map\n                mp.erase(words[i]);\n            }\n        }\n        // return the output length\n        return len;\n    }\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"longest-palindrome-by-concatenating-two-letter-words","has_notes":false}