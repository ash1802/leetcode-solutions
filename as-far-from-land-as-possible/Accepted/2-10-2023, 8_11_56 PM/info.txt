{"id":895378805,"lang":"cpp","lang_name":"C++","time":"3 months, 3 weeks","timestamp":1676040116,"status":10,"status_display":"Accepted","runtime":"83 ms","url":"/submissions/detail/895378805/","is_pending":"Not Pending","title":"As Far from Land as Possible","memory":"19.9 MB","code":"class Solution {\npublic:\n    int maxDistance(vector<vector<int>>& grid) {\n        // multisource breadth first search\n        int n = grid.size();\n        queue<pair<int,int>> q;\n\n        for(int i=0; i<n; i++) {\n            for(int j=0; j<n; j++) {\n                if(grid[i][j] == 1) {\n                    q.push({i,j});\n                }\n            }\n        }\n\n        int ans = -1;\n        vector<pair<int,int>> dir = {{0,1},{1,0},{0,-1},{-1,0}};\n        while(!q.empty()) {\n            pair<int,int> temp = q.front();\n            int r = temp.first;\n            int c = temp.second;\n            q.pop();\n\n            ans = grid[r][c];\n            for(int i=0; i<dir.size(); i++) {\n                int dr = dir[i].first;\n                int dc = dir[i].second;\n                \n                int newR = r+dr;\n                int newC = c+dc;\n\n                if(min(newR, newC) >= 0 && max(newR, newC) < n && grid[newR][newC] == 0) {\n                    q.push({newR, newC});\n                    grid[newR][newC] = grid[r][c] + 1;\n                }\n            }\n        }\n\n        return ans > 1 ? ans - 1 : -1;\n    }\n};","compare_result":"1111111111111111111111111111111111111","title_slug":"as-far-from-land-as-possible","has_notes":false}