{"id":956213700,"lang":"cpp","lang_name":"C++","time":"1 week, 2 days","timestamp":1684903407,"status":10,"status_display":"Accepted","runtime":"256 ms","url":"/submissions/detail/956213700/","is_pending":"Not Pending","title":"Maximum Subsequence Score","memory":"87.4 MB","code":"class Solution {\npublic:\n    // Define a shorthand for pair<int, int>\n    using int2 = pair<int, int>;\n\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\n        int n = nums1.size();\n        \n        // Create a vector of pairs to store the elements from nums1 and nums2\n        vector<int2> p(n);\n        for(int i = 0; i < n; i++){\n            p[i] = {nums2[i], nums1[i]};\n        }\n        \n        // Create a min heap using a priority queue to store the k smallest elements\n        priority_queue<int, vector<int>, greater<int>> pq;\n\n        // Sort the vector of pairs based on the first element in ascending order\n        // If the first elements are equal, sort based on the second element in ascending order\n        sort(p.begin(), p.end(), [](int2& x, int2& y){\n            if(x.first == y.first)\n                return x.second < y.second;\n            return x.first < y.first;\n        });\n\n        long long ans = 0, sum = 0;\n\n        // Iterate over the sorted vector of pairs in reverse order\n        for(int i = n - 1; i >= 0; i--){\n            auto& [x, y] = p[i];\n            \n            // Add the second element of the current pair to the sum\n            sum += y;\n            \n            // Push the second element of the current pair to the priority queue\n            pq.push(y);\n            \n            // Once i < n - k + 1, we have encountered k elements\n            if(i < n - k + 1){     \n                // If the priority queue size exceeds k, remove the smallest element\n                if(pq.size() > k){\n                    sum -= pq.top();\n                    pq.pop();\n                }\n                \n                // Calculate the product of the sum and the first element of the current pair\n                // Update the maximum score (ans) if necessary\n                ans = max(ans, sum * x);\n            }\n        }\n        \n        // Return the maximum score\n        return ans;\n    }\n};","compare_result":"1111111111111111111111111111","title_slug":"maximum-subsequence-score","has_notes":false}