{"id":899295606,"lang":"cpp","lang_name":"C++","time":"3 months, 2 weeks","timestamp":1676570936,"status":10,"status_display":"Accepted","runtime":"36 ms","url":"/submissions/detail/899295606/","is_pending":"Not Pending","title":"Serialize and Deserialize BST","memory":"27.8 MB","code":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode* left;\n *     TreeNode* right;\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n * };\n */\nclass Codec {\npublic:\n    // Encodes a tree to a single string.\n    string serialize(TreeNode* root) {\n        string result;\n        serialize(root, result);\n        return result;\n    }\n    \n    // storing preorder traversal for the given tree\n    void serialize(TreeNode* root, string& result) {\n        if (root == NULL) return;\n        result += to_string(root->val) + \",\";\n        serialize(root->left, result);\n        serialize(root->right, result);\n    }\n\n    TreeNode* deserialize(string data) {\n        if (data.empty()) return NULL;\n        // using a queue to process the nodes one by one\n        queue<string> q;\n        stringstream ss(data);\n        string s;\n        while (getline(ss, s, ',')) {\n            q.push(s);\n        }\n        return deserialize(q, INT_MIN, INT_MAX);\n    }\n    \n    // using the range method to construct BST as and when integers are fed to it.\n\n    TreeNode* deserialize(queue<string>& q, int lower, int upper) {\n        if (q.empty()) return NULL;\n        // get the front value and convert to integer\n        int val = stoi(q.front());\n        // if out of range that means we have to insert somewhere else\n        // so we return NULL for this particular link\n        if (val < lower || val > upper) return NULL;\n\n        // we have found a valid place for val to be inserted\n        q.pop();\n        // create a new node with this value, and make recursive calls for left and right\n        TreeNode* root = new TreeNode(val);\n        // left values will have range from lower limit to val\n        root->left = deserialize(q, lower, val);\n        // right values will have range from val to upper limit\n        root->right = deserialize(q, val, upper);\n        return root;\n    }\n};\n","compare_result":"11111111111111111111111111111111111111111111111111111111111111","title_slug":"serialize-and-deserialize-bst","has_notes":false}